# Coverage Requirements

This document explains our 100% coverage requirement and how it's enforced.

## What Does 100% Coverage Mean?

We enforce **four coverage metrics** at 100%:

1. **Line Coverage**: Every executable line must be run by tests
2. **Branch Coverage**: Every conditional branch (if/else, switch, ternary) must be tested
3. **Function Coverage**: Every function must be called
4. **Statement Coverage**: Every statement must be executed

### Example

```typescript
// ‚ùå BAD: Only 50% branch coverage
export function greet(name?: string) {
  if (name) {
    return `Hello, ${name}!`
  }
  return 'Hello, stranger!'
}

// Test (incomplete)
it('greets with name', () => {
  expect(greet('Alice')).toBe('Hello, Alice!')
})
// Missing: test for greet() without name
```

```typescript
// ‚úÖ GOOD: 100% branch coverage
export function greet(name?: string) {
  if (name) {
    return `Hello, ${name}!`
  }
  return 'Hello, stranger!'
}

// Tests (complete)
describe('greet', () => {
  it('greets with name', () => {
    expect(greet('Alice')).toBe('Hello, Alice!')
  })
  
  it('greets without name', () => {
    expect(greet()).toBe('Hello, stranger!')
  })
})
```

## How Coverage is Computed

We use [@vitest/coverage-v8](https://vitest.dev/guide/coverage.html), which uses V8's built-in coverage:

1. **Instrumentation**: V8 tracks which lines/branches are executed
2. **Collection**: Vitest collects coverage during test runs
3. **Reporting**: Coverage reports show covered vs. uncovered code
4. **Enforcement**: CI fails if any metric is below 100%

### Coverage Reports

After running tests with coverage:

```bash
cd apps/web
pnpm test -- --coverage
```

You'll get:

1. **Console output**: Quick summary per file
2. **JSON reports**: Machine-readable data in `coverage/coverage-summary.json`
3. **HTML reports**: Visual report in `coverage/index.html`

```bash
# View HTML report
open coverage/index.html
```

The HTML report shows:
- ‚úÖ Green: Covered lines
- ‚ùå Red: Uncovered lines
- üü° Yellow: Partially covered branches

## What is Excluded from Coverage

### Automatically Excluded

These files are automatically excluded by our Vitest config:

```typescript
// vitest.config.ts
coverage: {
  exclude: [
    '**/*.test.ts',        // Test files
    '**/*.test.tsx',
    '**/*.spec.ts',
    '**/*.spec.tsx',
    '**/node_modules/**',  // Dependencies
    '**/dist/**',          // Build output
    '**/.next/**',         // Next.js build
    'vitest.config.ts',    // Config files
    'tailwind.config.ts',
    'src/index.ts',        // Re-export files (barrel exports)
  ]
}
```

### Generated Code

Generated code must be excluded with **proof** of generation:

- **Proto/gRPC files**: Include `.proto` files showing source
- **GraphQL types**: Include schema files
- **Database migrations**: Generated by ORM tools
- **Build artifacts**: In `.next/`, `dist/`, etc.

### Platform-Specific Code

Code that cannot be deterministically tested:

```typescript
// ‚ùå Cannot test reliably
if (process.platform === 'win32') {
  // Windows-specific code
}

// ‚úÖ Can test with mocks
export function getPlatformCommand() {
  return process.platform === 'win32' ? 'cmd' : 'bash'
}

// Test
vi.stubGlobal('process', { platform: 'win32' })
expect(getPlatformCommand()).toBe('cmd')
```

### UI Layout Code

Pure JSX layout with no logic:

```typescript
// ‚ùå Hard to test meaningfully
export function Layout({ children }) {
  return (
    <div className="container">
      <nav>...</nav>
      <main>{children}</main>
      <footer>...</footer>
    </div>
  )
}

// ‚úÖ Extract logic to testable utilities
export function getLayoutClasses(theme: string) {
  return theme === 'dark' ? 'bg-black text-white' : 'bg-white text-black'
}
```

## Exceptions Register

If a file **truly** cannot reach 100% coverage:

1. Document it in [99_EXCEPTIONS.md](./99_EXCEPTIONS.md)
2. Explain **why** it can't be tested
3. Describe **mitigation** (how we reduce reliance on untested code)
4. Get **team approval** (via PR review)

### Exception Template

````markdown
## apps/web/middleware.ts

**Reason**: Next.js middleware runs in Edge Runtime with limited Node.js APIs. Cannot be tested in standard Node.js environment.

**Current Coverage**: ~75%

**Mitigation**:
- Keep middleware logic minimal
- Extract testable logic to `lib/middleware-logic.ts` (100% coverage)
- E2E tests verify behavior in real Edge environment

**Approved**: 2024-02-04 (PR #123)
**Review Date**: 2024-05-04 (quarterly review)
````

## Adding Tests for New Code

### Workflow

1. **Write code** with tests (TDD) or tests after code
2. **Run coverage** to verify 100%
3. **Fix gaps** if coverage is below 100%
4. **Commit** when coverage is 100%

### Step-by-Step

```bash
# 1. Write your code
vim apps/web/lib/my-feature.ts

# 2. Write tests
vim apps/web/lib/my-feature.test.ts

# 3. Run tests with coverage
cd apps/web
pnpm test -- --coverage my-feature

# 4. Check coverage report
open coverage/index.html

# 5. Add missing tests until 100%
# (repeat steps 2-4)

# 6. Commit
git add apps/web/lib/my-feature.ts apps/web/lib/my-feature.test.ts
git commit -m "feat: add my-feature with 100% coverage"
```

### Example: Adding a Utility Function

```typescript
// apps/web/lib/math.ts
export function add(a: number, b: number): number {
  return a + b
}

export function divide(a: number, b: number): number {
  if (b === 0) {
    throw new Error('Division by zero')
  }
  return a / b
}
```

```typescript
// apps/web/lib/math.test.ts
import { describe, it, expect } from 'vitest'
import { add, divide } from './math'

describe('add', () => {
  it('adds two numbers', () => {
    expect(add(2, 3)).toBe(5)
  })
  
  it('handles negative numbers', () => {
    expect(add(-1, -1)).toBe(-2)
  })
})

describe('divide', () => {
  it('divides two numbers', () => {
    expect(divide(10, 2)).toBe(5)
  })
  
  it('throws on division by zero', () => {
    expect(() => divide(10, 0)).toThrow('Division by zero')
  })
})
```

Coverage: ‚úÖ 100% (all lines, all branches)

## Coverage Gates

### Local Enforcement

Before committing:

```bash
# Run coverage check
pnpm test -- --coverage
node scripts/ci/check-coverage-strict.js
```

If it fails, you **cannot** merge until fixed.

### CI Enforcement

On every PR and push to `main`:

```yaml
# .github/workflows/ci.yml
- name: Test
  run: pnpm test -- --coverage

- name: Enforce coverage thresholds
  run: node scripts/ci/check-coverage-strict.js
```

CI will **fail** if:
- Any package is below 100% on any metric
- Coverage report is missing
- Tests fail

### Pre-commit Hook (Optional)

Add to `.githooks/pre-commit`:

```bash
#!/bin/bash
pnpm test -- --coverage --run
node scripts/ci/check-coverage-strict.js
```

## "No Merge if Coverage Drops" Policy

### The Rule

- ‚úÖ **Allowed**: Add new code with 100% coverage
- ‚úÖ **Allowed**: Improve coverage of existing code
- ‚ùå **Blocked**: Add code with <100% coverage
- ‚ùå **Blocked**: Reduce coverage of existing code

### Enforcement

1. **CI check**: Fails if coverage drops
2. **Code review**: Reviewers verify coverage reports
3. **Merge blocks**: GitHub branch protection requires passing CI

### Exceptions Process

If you believe an exception is warranted:

1. Open a PR with your code
2. Document the exception in [99_EXCEPTIONS.md](./99_EXCEPTIONS.md)
3. Explain why 100% is impossible/impractical
4. Show mitigation strategies
5. Get approval from 2+ maintainers
6. Set a review date (quarterly)

## Troubleshooting

### "Coverage is at 99%"

One line missing? Check the HTML report:

```bash
cd apps/web
pnpm test -- --coverage
open coverage/index.html
```

Look for red (uncovered) lines. Add a test case.

### "Coverage shows 100% but CI fails"

Different packages may have different coverage:

```bash
# Check all packages
pnpm test -- --coverage
node scripts/ci/check-coverage-strict.js
```

Fix the failing package specifically.

### "Can't test this code"

Ask yourself:
1. Can I refactor to make it testable?
2. Can I mock dependencies?
3. Can I extract testable logic?

If truly impossible, document in [99_EXCEPTIONS.md](./99_EXCEPTIONS.md).

### "Coverage is slow"

For large packages:

1. **Run specific tests** during development:
   ```bash
   pnpm test my-feature --coverage
   ```

2. **Run full coverage** before committing:
   ```bash
   pnpm test -- --coverage
   ```

3. **Let CI** handle final verification

## Best Practices

### 1. Write Tests First (TDD)

```typescript
// 1. Write test
it('formats currency', () => {
  expect(formatCurrency(1234.56)).toBe('$1,234.56')
})

// 2. Implement
export function formatCurrency(amount: number): string {
  return `$${amount.toFixed(2)}`
}

// 3. Refine
```

### 2. Test All Branches

```typescript
export function getStatus(code: number): string {
  if (code >= 200 && code < 300) return 'success'
  if (code >= 400 && code < 500) return 'client-error'
  if (code >= 500) return 'server-error'
  return 'unknown'
}

// Test ALL branches
describe('getStatus', () => {
  it('returns success for 2xx', () => expect(getStatus(200)).toBe('success'))
  it('returns client-error for 4xx', () => expect(getStatus(404)).toBe('client-error'))
  it('returns server-error for 5xx', () => expect(getStatus(500)).toBe('server-error'))
  it('returns unknown for others', () => expect(getStatus(100)).toBe('unknown'))
})
```

### 3. Test Error Paths

```typescript
export function parseJSON(text: string): unknown {
  try {
    return JSON.parse(text)
  } catch {
    return null
  }
}

// Test both success and failure
describe('parseJSON', () => {
  it('parses valid JSON', () => {
    expect(parseJSON('{"a":1}')).toEqual({ a: 1 })
  })
  
  it('returns null for invalid JSON', () => {
    expect(parseJSON('not json')).toBeNull()
  })
})
```

### 4. Use Coverage as a Guide

Coverage is a **minimum**, not a **target**:

- ‚úÖ 100% coverage + good assertions = high confidence
- ‚ùå 100% coverage + weak assertions = false confidence

Write meaningful tests, not just coverage-passing tests.

## Summary

- **Requirement**: 100% line, branch, function, and statement coverage
- **Tool**: @vitest/coverage-v8
- **Enforcement**: CI fails if below 100%
- **Exceptions**: Documented in [99_EXCEPTIONS.md](./99_EXCEPTIONS.md)
- **Reports**: HTML reports show uncovered code
- **Policy**: No merge if coverage drops

For patterns and examples, see [30_TEST_PATTERNS.md](./30_TEST_PATTERNS.md).
